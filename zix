#!/usr/bin/env python3

from __future__ import annotations
import argparse
import hashlib
import json
import os
import pathlib
import shutil
import subprocess
import sys
import tempfile
import time
from typing import Dict, List, Optional
import re
import textwrap

HOME = pathlib.Path.home().resolve()
LOCAL_DIR = HOME / ".local" / "share" / "zix"
LOCAL_DIR.mkdir(parents=True, exist_ok=True)
CONFIG_DIR = HOME / ".config" / "zix"
CONFIG_DIR.mkdir(parents=True, exist_ok=True)

MANIFEST_FILE = CONFIG_DIR / "zix.json"
STATE_FILE = LOCAL_DIR / "state.json"


FLAKE_TEMPLATE = textwrap.dedent("""\
{{
  description = "zix generated profile";

  inputs = {{
    {nixpkgs_line}
    flake-utils.url = "github:numtide/flake-utils";
  }};

  outputs = {{ self, nixpkgs, flake-utils }}:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${{system}};
        env = pkgs.buildEnv {{
          name = "zix-profile";
          paths = with pkgs; [
{pkg_refs}
          ];
        }};
        switchScript = pkgs.writeShellScriptBin "switch" ''
          nix-env --set ${{env}}
        '';
        rollbackScript = pkgs.writeShellScriptBin "rollback" ''
          nix-env --rollback
        '';
      in {{
        defaultPackage = env;
        apps = {{
          profile = {{
            switch = {{
              type = "app";
              program = "${{switchScript}}/bin/switch";
            }};
            rollback = {{
              type = "app";
              program = "${{rollbackScript}}/bin/rollback";
            }};
          }};
        }};
      }});
}}
""")


def _print_stderr(msg: str) -> None:
    print(msg, file=sys.stderr)


def info(msg: str) -> None:
    print(f"\033[1;34m[info]\033[0m {msg}")


def ok(msg: str) -> None:
    print(f"\033[1;32m[ok]\033[0m {msg}")


def warn(msg: str) -> None:
    print(f"\033[1;33m[warn]\033[0m {msg}")


def error(msg: str) -> None:
    _print_stderr(f"\033[1;31m[error]\033[0m {msg}")


def atomic_write(path: pathlib.Path, data: str, mode: int = 0o644) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    fd, tmp = tempfile.mkstemp(
        prefix=f".{path.name}.tmp.", dir=str(path.parent))
    try:
        with os.fdopen(fd, "w") as f:
            f.write(data)
        os.chmod(tmp, mode)
        shutil.move(tmp, str(path))
    finally:
        if os.path.exists(tmp):
            try:
                os.remove(tmp)
            except Exception:
                pass


def read_json(path: pathlib.Path, default=None):
    if not path.exists():
        return default if default is not None else {}
    try:
        with path.open("r") as f:
            return json.load(f)
    except Exception as exc:
        error(f"Failed to read JSON from {path}: {exc}")
        return default if default is not None else {}


def write_json(path: pathlib.Path, data) -> None:
    atomic_write(path, json.dumps(data, indent=2) + "\n")


PKG_NAME_RE = re.compile(r"^[A-Za-z0-9_.+-]+$")


def validate_pkg_name(name: str) -> None:
    if not PKG_NAME_RE.match(name):
        raise ValueError(
            "package name must match [A-Za-z0-9_.+-] (no spaces).")


def normalize_manifest(man: Dict) -> Dict:
    pkgs = man.get("packages", [])
    if not isinstance(pkgs, list):
        raise ValueError("manifest 'packages' must be a list")
    cleaned: List[str] = []
    for p in pkgs:
        if not isinstance(p, str):
            raise ValueError(f"package {p!r} is not a string")
        s = p.strip()
        if s:
            cleaned.append(s)
    unique_sorted = sorted(set(cleaned))
    return {"packages": unique_sorted}


def read_manifest() -> Dict:
    if not MANIFEST_FILE.exists():
        return {"packages": []}
    raw = read_json(MANIFEST_FILE, {"packages": []})
    try:
        return normalize_manifest(raw)
    except ValueError as exc:
        error(f"Manifest validation error: {exc}")
        sys.exit(1)


def write_manifest(man: Dict) -> None:
    norm = normalize_manifest(man)
    write_json(MANIFEST_FILE, norm)


def read_state() -> Dict:
    return read_json(STATE_FILE, {})


def save_state(state: Dict) -> None:
    write_json(STATE_FILE, state)


def manifest_hash(man: Dict) -> str:
    txt = json.dumps(man, sort_keys=True, separators=(",", ":"))
    return hashlib.sha256(txt.encode("utf-8")).hexdigest()[:12]


def flake_dir_for_hash(hash_: str) -> pathlib.Path:
    return LOCAL_DIR / f"flake-{hash_}"


def current_flake_dir() -> Optional[pathlib.Path]:
    st = read_state()
    p = st.get("current_flake")
    return pathlib.Path(p) if p else None


def generate_flake_nix_text(packages: List[str],
                            nixpkgs_ref: Optional[str] = None) -> str:
    if nixpkgs_ref:
        nixpkgs_line = f'nixpkgs.url = "{nixpkgs_ref}";'
    else:
        nixpkgs_line = 'nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";'
    pkg_lines = [f"            pkgs.{pkg}" for pkg in packages]
    pkg_refs = "\n".join(pkg_lines) if pkg_lines else ""
    return FLAKE_TEMPLATE.format(nixpkgs_line=nixpkgs_line, pkg_refs=pkg_refs)


def ensure_nix_available() -> bool:
    return shutil.which("nix") is not None


def run_proc(cmd: List[str],
             cwd: Optional[pathlib.Path] = None,
             check: bool = True) -> int:
    try:
        info(f"Running: {' '.join(cmd)}")
        res = subprocess.run(cmd, cwd=str(cwd) if cwd else None, check=check)
        return res.returncode
    except subprocess.CalledProcessError as e:
        error(f"Command failed (exit {e.returncode}): {' '.join(cmd)}")
        return e.returncode
    except FileNotFoundError:
        error(f"Command not found: {cmd[0]}")
        return 127


def build_flake(force: bool = False, show: bool = False) -> None:
    man = read_manifest()
    h = manifest_hash(man)
    flake_dir = flake_dir_for_hash(h)
    flake_dir.mkdir(parents=True, exist_ok=True)
    flake_path = flake_dir / "flake.nix"
    generated = generate_flake_nix_text(
        man.get("packages", []), man.get("nixpkgs"))
    if flake_path.exists() and not force:
        existing = flake_path.read_text()
        if existing == generated:
            ok(f"flake already up-to-date: {flake_dir}")
            state = read_state()
            state["current_flake"] = str(flake_dir.resolve())
            save_state(state)
            if show:
                print(generated)
            return
    atomic_write(flake_path, generated)
    ok(f"Generated flake.nix at: {flake_path}")
    if show:
        print("----- flake.nix -----")
        print(generated)
        print("---------------------")
    if ensure_nix_available():
        rc = run_proc(
            ["nix", "flake", "lock"],
            cwd=flake_dir,
            check=False
        )
        if rc == 0:
            ok("Updated flake.lock")
        else:
            warn("Failed to update flake.lock (continuing)")
    else:
        warn("nix CLI not found; skipping flake.lock")
    state = read_state()
    state["current_flake"] = str(flake_dir.resolve())
    state["manifest_hash"] = h
    state["last_built"] = int(time.time())
    save_state(state)
    ok(f"Flake stored at: {flake_dir}")


def apply_profile() -> None:
    state = read_state()
    flake = pathlib.Path(state.get("current_flake")).resolve()
    if not flake:
        error("No flake built yet. Run `zix build` first.")
        return
    if not ensure_nix_available():
        error("nix CLI not found; cannot apply profile.")
        return
    run_proc(["nix", "run", f"path:{str(flake)}#profile.switch"], cwd=flake)


def rollback_profile() -> None:
    state = read_state()
    flake = pathlib.Path(state.get("current_flake")).resolve()
    if not flake:
        error("No flake built yet. Run `zix build` first.")
        return
    if not ensure_nix_available():
        error("nix CLI not found; cannot rollback profile.")
        return
    run_proc(["nix", "run", f"path:{str(flake)}#profile.rollback"], cwd=flake)


def get_installed_packages() -> Optional[set[str]]:
    try:
        current_env = subprocess.check_output(
            ["readlink", "-f", os.path.expanduser("~/.nix-profile")],
            text=True
        ).strip()

        if not current_env:
            warn("No nix environment currently active")
            return None

        info(f"Current environment: {os.path.basename(current_env)}")

        if "zix-profile" not in current_env:
            warn("Not a zix environment")
            return None

        # Get derivation path
        drv_path = subprocess.check_output(
            ["nix-store", "--query", "--deriver", current_env],
            text=True
        ).strip()

        # Get derivation JSON
        drv_json = subprocess.check_output(
            ["nix", "derivation", "show", drv_path],
            text=True
        )

        pattern = r'/nix/store/[^/]+-([a-zA-Z0-9._+-]+?)-[\d.]+(?:-|$)'
        installed_packages = set(re.findall(pattern, drv_json))

        if not installed_packages:
            # Fallback to JSON parsing if regex fails
            drv_data = json.loads(drv_json)
            pkgs_json = list(drv_data.values())[0]["env"]["pkgs"]
            pkgs_data = json.loads(pkgs_json)
            installed_packages = set()

            for item in pkgs_data:
                for path in item["paths"]:
                    basename = os.path.basename(path)
                    pkg_name = re.sub(r'^[^-]+-', '', basename)
                    pkg_name = re.sub(r'-[0-9][^-]*$', '', pkg_name)
                    installed_packages.add(pkg_name)

        return installed_packages

    except subprocess.CalledProcessError as e:
        if "No such file or directory" in str(e):
            warn("No nix environment currently active")
        else:
            warn(f"Could not query installed packages: {e}")
        return None
    except (json.JSONDecodeError, KeyError, IndexError) as e:
        error(f"Failed to parse derivation data: {e}")
        return None
    except Exception as e:
        error(f"Unexpected error: {e}")
        return None


def compare_manifest_with_installed(manifest_packages: set[str],
                                    installed_packages: set[str]) -> None:
    if manifest_packages == installed_packages:
        ok("Environment is in sync with manifest")
        return

    warn("Out of sync!")

    missing = manifest_packages - installed_packages
    extra = installed_packages - manifest_packages

    if missing:
        print(f"  Missing packages: {', '.join(sorted(missing))}")
    if extra:
        print(f"  Extra packages: {', '.join(sorted(extra))}")

    print()
    info("Sync using: zix build && zix apply")


def cmd_init() -> None:
    if MANIFEST_FILE.exists():
        warn("Manifest already exists; no changes made.")
        return
    write_manifest({"packages": []})
    ok("Created zix.json (empty manifest).")


def cmd_add(pkg: str) -> None:
    try:
        validate_pkg_name(pkg)
    except ValueError as exc:
        error(str(exc))
        return
    man = read_manifest()
    if pkg in man["packages"]:
        warn(f"{pkg} already present.")
        return
    man["packages"].append(pkg)
    write_manifest(man)
    ok(f"Added {pkg} to manifest.")


def cmd_remove(pkg: str) -> None:
    man = read_manifest()
    if pkg not in man["packages"]:
        warn(f"{pkg} not in manifest.")
        return
    man["packages"].remove(pkg)
    write_manifest(man)
    ok(f"Removed {pkg} from manifest.")


def cmd_list() -> None:
    man = read_manifest()
    manifest_packages = set(man.get("packages", []))

    info("Manifest packages:")
    if manifest_packages:
        for p in sorted(manifest_packages):
            print(f"  - {p}")
    else:
        print("  (none)")
    print()

    installed_packages = get_installed_packages()

    if installed_packages is None:
        info("Apply using: zix apply")
        return

    info(f"Installed packages ({len(installed_packages)}):")
    for pkg in sorted(installed_packages):
        print(f"  - {pkg}")

    print()
    compare_manifest_with_installed(manifest_packages, installed_packages)


def cmd_search(term: str) -> None:
    if not ensure_nix_available():
        error("nix CLI not found; cannot search.")
        return
    run_proc(["nix", "search", "nixpkgs", term])


def cmd_status() -> None:
    man = read_manifest()
    h = manifest_hash(man)
    state = read_state()
    print(f"manifest: {MANIFEST_FILE.resolve()}")
    print(f"manifest-hash: {h}")
    print(f"packages: {len(man.get('packages', []))}")
    active = state.get("current_flake")
    if active:
        print(f"active_flake: {active}")
        last = state.get("last_built")
        if last:
            print(f"last_built: {time.ctime(last)}")
    else:
        print("active_flake: (none)")


def main(argv=None) -> None:
    description = "zix - declarative & imperative user profile manager for Nix"
    epilog = "Examples: zix init | zix add git | zix build --show | zix apply"
    parser = argparse.ArgumentParser(
        prog="zix",
        description=description,
        epilog=epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    sub = parser.add_subparsers(dest="cmd", required=True)
    sub.add_parser("init", help="create a new zix.json manifest")
    p_add = sub.add_parser(
        "add", help="add package(s) to manifest (nixpkgs attribute names)")
    p_add.add_argument("pkgs", nargs="+",
                       help="package name(s) (nix attributes)")
    p_rm = sub.add_parser("remove", help="remove package(s) from manifest")
    p_rm.add_argument("pkgs", nargs="+",
                      help="package name(s) (nix attributes)")
    sub.add_parser("list", help="list declared packages")
    p_build = sub.add_parser(
        "build", help="generate flake for current manifest")
    p_build.add_argument("--force", "-f", action="store_true",
                         help="force regeneration even if unchanged")
    p_build.add_argument("--show", action="store_true",
                         help="print generated flake.nix to stdout")
    sub.add_parser("apply", help="apply last generated flake to profile")
    sub.add_parser("rollback", help="rollback profile to previous generation")
    p_search = sub.add_parser("search", help="search nixpkgs via nix search")
    p_search.add_argument("term", help="search term")
    sub.add_parser("status", help="show manifest hash and active flake")
    args = parser.parse_args(argv)
    if args.cmd == "init":
        cmd_init()
    elif args.cmd == "add":
        for pkg in args.pkgs:
            cmd_add(pkg)
    elif args.cmd == "remove":
        for pkg in args.pkgs:
            cmd_remove(pkg)
    elif args.cmd == "list":
        cmd_list()
    elif args.cmd == "build":
        build_flake(force=args.force, show=args.show)
    elif args.cmd == "apply":
        apply_profile()
    elif args.cmd == "rollback":
        rollback_profile()
    elif args.cmd == "search":
        cmd_search(args.term)
    elif args.cmd == "status":
        cmd_status()
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
