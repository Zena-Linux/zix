#!/usr/bin/env python3

from __future__ import annotations
import argparse
import json
import os
import pathlib
import shutil
import subprocess
import sys
import tempfile
import time
from typing import Dict, List, Optional
import re
import textwrap

HOME = pathlib.Path.home().resolve()
LOCAL_DIR = HOME / ".local" / "share" / "zix"
LOCAL_DIR.mkdir(parents=True, exist_ok=True)
CONFIG_DIR = HOME / ".config" / "zix"
CONFIG_DIR.mkdir(parents=True, exist_ok=True)

MANIFEST_FILE = CONFIG_DIR / "zix.json"
STATE_FILE = LOCAL_DIR / "state.json"

FLAKE_TEMPLATE = textwrap.dedent("""\
{{
  description = "zix generated profile";

  inputs = {{
    {nixpkgs_line}
    flake-utils.url = "github:numtide/flake-utils";
  }};

  outputs = {{ self, nixpkgs, flake-utils }}:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${{system}};
        env = pkgs.buildEnv {{
          name = "zix-profile";
          paths = with pkgs; [
{pkg_refs}
          ];
        }};
        switchScript = pkgs.writeShellScriptBin "switch" ''
          nix-env --set ${{env}}
        '';
        rollbackScript = pkgs.writeShellScriptBin "rollback" ''
          nix-env --rollback
        '';
      in {{
        defaultPackage = env;
        apps = {{
          profile = {{
            switch = {{
              type = "app";
              program = "${{switchScript}}/bin/switch";
            }};
            rollback = {{
              type = "app";
              program = "${{rollbackScript}}/bin/rollback";
            }};
          }};
        }};
      }});
}}
""")


def _print_stderr(msg: str) -> None:
    print(msg, file=sys.stderr)


def info(msg: str) -> None:
    print(f"\033[1;34m[info]\033[0m {msg}")


def ok(msg: str) -> None:
    print(f"\033[1;32m[ok]\033[0m {msg}")


def warn(msg: str) -> None:
    print(f"\033[1;33m[warn]\033[0m {msg}")


def error(msg: str) -> None:
    _print_stderr(f"\033[1;31m[error]\033[0m {msg}")


def atomic_write(path: pathlib.Path, data: str, mode: int = 0o644) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    fd, tmp = tempfile.mkstemp(
        prefix=f".{path.name}.tmp.", dir=str(path.parent))
    try:
        with os.fdopen(fd, "w") as f:
            f.write(data)
        os.chmod(tmp, mode)
        shutil.move(tmp, str(path))
    finally:
        if os.path.exists(tmp):
            try:
                os.remove(tmp)
            except Exception:
                pass


def read_json(path: pathlib.Path, default=None):
    if not path.exists():
        return default if default is not None else {}
    try:
        with path.open("r") as f:
            return json.load(f)
    except Exception as exc:
        error(f"Failed to read JSON from {path}: {exc}")
        return default if default is not None else {}


def write_json(path: pathlib.Path, data) -> None:
    atomic_write(path, json.dumps(data, indent=2) + "\n")


PKG_NAME_RE = re.compile(r"^[A-Za-z0-9_.+-]+$")


def validate_pkg_name(name: str) -> None:
    if not PKG_NAME_RE.match(name):
        raise ValueError(
            "package name must match [A-Za-z0-9_.+-] (no spaces).")


def normalize_manifest(man: Dict) -> Dict:
    pkgs = man.get("packages", [])
    if not isinstance(pkgs, list):
        raise ValueError("manifest 'packages' must be a list")
    cleaned: List[str] = []
    for p in pkgs:
        if not isinstance(p, str):
            raise ValueError(f"package {p!r} is not a string")
        s = p.strip()
        if s:
            cleaned.append(s)
    unique_sorted = sorted(set(cleaned))
    return {"packages": unique_sorted,
            **({k: v for k, v in man.items() if k != "packages"})}


def read_manifest() -> Dict:
    if not MANIFEST_FILE.exists():
        return {"packages": []}
    raw = read_json(MANIFEST_FILE, {"packages": []})
    try:
        return normalize_manifest(raw)
    except ValueError as exc:
        error(f"Manifest validation error: {exc}")
        sys.exit(1)


def write_manifest(man: Dict) -> None:
    norm = normalize_manifest(man)
    write_json(MANIFEST_FILE, norm)


def read_state() -> Dict:
    return read_json(STATE_FILE, {})


def save_state(state: Dict) -> None:
    write_json(STATE_FILE, state)


def flake_dir() -> pathlib.Path:
    d = LOCAL_DIR / "flake"
    d.mkdir(parents=True, exist_ok=True)
    return d


def generate_flake_nix_text(packages: List[str],
                            nixpkgs_ref: Optional[str] = None) -> str:
    if nixpkgs_ref:
        nixpkgs_line = f'nixpkgs.url = "{nixpkgs_ref}";'
    else:
        nixpkgs_line = 'nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";'
    pkg_lines = [f"            pkgs.{pkg}" for pkg in packages]
    pkg_refs = "\n".join(pkg_lines) if pkg_lines else ""
    return FLAKE_TEMPLATE.format(nixpkgs_line=nixpkgs_line, pkg_refs=pkg_refs)


def ensure_nix_available() -> bool:
    return shutil.which("nix") is not None


def run_proc(cmd: List[str],
             cwd: Optional[pathlib.Path] = None,
             check: bool = True) -> int:
    try:
        info(f"Running: {' '.join(cmd)}")
        res = subprocess.run(cmd, cwd=str(cwd) if cwd else None, check=check)
        return res.returncode
    except subprocess.CalledProcessError as e:
        error(f"Command failed (exit {e.returncode}): {' '.join(cmd)}")
        return e.returncode
    except FileNotFoundError:
        error(f"Command not found: {cmd[0]}")
        return 127


def get_installed_packages() -> Optional[set[str]]:
    try:
        current_env = subprocess.check_output(
            ["readlink", "-f", os.path.expanduser("~/.nix-profile")],
            text=True
        ).strip()

        if not current_env:
            warn("No nix environment currently active")
            return None

        info(f"Current environment: {os.path.basename(current_env)}")

        if "zix-profile" not in current_env:
            warn("Not a zix environment")
            return None

        drv_path = subprocess.check_output(
            ["nix-store", "--query", "--deriver", current_env],
            text=True
        ).strip()

        drv_json = subprocess.check_output(
            ["nix", "derivation", "show", drv_path],
            text=True
        )

        pattern = r'/nix/store/[^/]+-([a-zA-Z0-9._+-]+?)-[\d.]+(?:-|$)'
        installed_packages = set(re.findall(pattern, drv_json))

        if not installed_packages:
            drv_data = json.loads(drv_json)
            pkgs_json = list(drv_data.values())[0]["env"]["pkgs"]
            pkgs_data = json.loads(pkgs_json)
            installed_packages = set()
            for item in pkgs_data:
                for path in item["paths"]:
                    basename = os.path.basename(path)
                    pkg_name = re.sub(r'^[^-]+-', '', basename)
                    pkg_name = re.sub(r'-[0-9][^-]*$', '', pkg_name)
                    installed_packages.add(pkg_name)

        return installed_packages

    except Exception as e:
        warn(f"Could not query installed packages: {e}")
        return None


def compare_manifest_with_installed(manifest_packages: set[str],
                                    installed_packages: set[str]) -> None:
    if manifest_packages == installed_packages:
        ok("Environment is in sync with manifest")
        return

    warn("Out of sync!")
    missing = manifest_packages - installed_packages
    extra = installed_packages - manifest_packages

    if missing:
        print(f"  Missing packages: {', '.join(sorted(missing))}")
    if extra:
        print(f"  Extra packages: {', '.join(sorted(extra))}")

    print()
    info("Sync using: zix build && zix apply")


def cmd_init() -> None:
    if MANIFEST_FILE.exists():
        warn("Manifest already exists; no changes made.")
        return
    write_manifest({"packages": []})
    ok("Created zix.json (empty manifest).")


def cmd_add(pkg: str) -> None:
    try:
        validate_pkg_name(pkg)
    except ValueError as exc:
        error(str(exc))
        return
    man = read_manifest()
    if pkg in man["packages"]:
        warn(f"{pkg} already present.")
        return
    man["packages"].append(pkg)
    write_manifest(man)
    ok(f"Added {pkg} to manifest.")


def cmd_remove(pkg: str) -> None:
    man = read_manifest()
    if pkg not in man["packages"]:
        warn(f"{pkg} not in manifest.")
        return
    man["packages"].remove(pkg)
    write_manifest(man)
    ok(f"Removed {pkg} from manifest.")


def cmd_list() -> None:
    man = read_manifest()
    manifest_packages = set(man.get("packages", []))

    info("Manifest packages:")
    if manifest_packages:
        for p in sorted(manifest_packages):
            print(f"  - {p}")
    else:
        print("  (none)")

    print()
    installed_packages = get_installed_packages()

    if installed_packages is None:
        info("Apply using: zix apply")
        return

    info(f"Installed packages ({len(installed_packages)}):")
    for pkg in sorted(installed_packages):
        print(f"  - {pkg}")

    print()
    compare_manifest_with_installed(manifest_packages, installed_packages)


def build_cmd(force: bool = False, show: bool = False) -> None:
    flake_d = flake_dir()
    flake_path = flake_d / "flake.nix"
    man = read_manifest()
    generated = generate_flake_nix_text(
        man.get("packages", []), man.get("nixpkgs")
    )

    if flake_path.exists() and flake_path.read_text() == \
            generated and not force:
        ok("flake already up-to-date")
    else:
        atomic_write(flake_path, generated)
        ok(f"Written flake to {flake_path}")

    if show:
        print("----- flake.nix -----")
        print(generated)
        print("---------------------")

    if ensure_nix_available():
        run_proc(["nix", "flake", "lock"], cwd=flake_d, check=False)
    else:
        warn("nix CLI not found; skipping lock")

    state = read_state()
    state["current_flake"] = str(flake_d.resolve())
    state["last_built"] = int(time.time())
    save_state(state)


def cmd_apply() -> None:
    state = read_state()
    flake = state.get("current_flake")
    if not flake:
        error("No flake built yet. Run `zix build` first.")
        return
    if not ensure_nix_available():
        error("nix CLI not found; cannot apply.")
        return
    run_proc(["nix", "run", f"path:{
             flake}#profile.switch"], cwd=pathlib.Path(flake))


def cmd_rollback() -> None:
    state = read_state()
    flake = state.get("current_flake")
    if not flake:
        error("No flake built yet.")
        return
    if not ensure_nix_available():
        error("nix CLI not found; cannot rollback.")
        return
    run_proc(["nix", "run", f"path:{
             flake}#profile.rollback"], cwd=pathlib.Path(flake))


def cmd_status() -> None:
    man = read_manifest()
    manifest_packages = set(man.get("packages", []))
    state = read_state()

    print(f"manifest: {MANIFEST_FILE.resolve()}")
    print(f"packages: {len(manifest_packages)}")

    installed_packages = get_installed_packages()
    if installed_packages is not None:
        print()
        compare_manifest_with_installed(manifest_packages, installed_packages)

    print()
    active = state.get("current_flake")
    if active:
        print(f"active_flake: {active}")
        last = state.get("last_built")
        if last:
            print(f"last_built: {time.ctime(last)}")
    else:
        print("active_flake: (none)")


def main(argv=None) -> None:
    description = "zix - declarative & imperative user profile manager for Nix"
    epilog = textwrap.dedent(
        "Examples:\n"
        "  zix init\n"
        "  zix add git\n"
        "  zix build --show\n"
        "  zix apply\n"
        "  zix status\n"
        "  zix list\n"
    )

    parser = argparse.ArgumentParser(
        prog="zix",
        description=description,
        epilog=epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    sub = parser.add_subparsers(dest="cmd", required=True)

    sub.add_parser("init", help="create a new zix.json manifest")

    p_add = sub.add_parser(
        "add", help="add package(s) to manifest (nixpkgs attribute names)"
    )
    p_add.add_argument(
        "pkgs",
        nargs="+",
        help="package name(s) (nix attribute names, e.g., git)",
    )

    p_rm = sub.add_parser(
        "remove", help="remove package(s) from manifest"
    )
    p_rm.add_argument(
        "pkgs",
        nargs="+",
        help="package name(s) (nix attribute names)",
    )

    sub.add_parser(
        "list", help="list declared packages and installed packages")
    p_build = sub.add_parser(
        "build", help="generate or update the flake for current manifest"
    )
    p_build.add_argument(
        "--force", "-f",
        action="store_true",
        help="force regeneration even if unchanged",
    )
    p_build.add_argument(
        "--show",
        action="store_true",
        help="print generated flake.nix to stdout",
    )

    sub.add_parser(
        "apply", help="apply the last built flake to your Nix profile")
    sub.add_parser(
        "rollback", help="rollback the profile via nix profile rollback")
    sub.add_parser(
        "status", help="show manifest, sync status, and active flake")

    args = parser.parse_args(argv)

    if args.cmd == "init":
        cmd_init()
    elif args.cmd == "add":
        for pkg in args.pkgs:
            cmd_add(pkg)
    elif args.cmd == "remove":
        for pkg in args.pkgs:
            cmd_remove(pkg)
    elif args.cmd == "list":
        cmd_list()
    elif args.cmd == "build":
        build_cmd(force=args.force, show=args.show)
    elif args.cmd == "apply":
        cmd_apply()
    elif args.cmd == "rollback":
        cmd_rollback()
    elif args.cmd == "status":
        cmd_status()
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
